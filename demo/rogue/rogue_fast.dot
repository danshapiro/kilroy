digraph rogue_fast {
    graph [
        goal="Port the classic Rogue 5.4.4 game from C to Rust/WASM, playable in a browser via a single HTML page with classic ASCII terminal rendering — exact mechanical port of all game systems, compiled to WebAssembly and served from demo/rogue/rogue-wasm/www/index.html",
        rankdir=LR,
        default_max_retry=3,
        retry_target="impl_integration",
        fallback_retry_target="impl_scaffold",
        default_command_timeout_ms=300000,
        max_command_timeout_ms=1800000,
        provenance_version="1",
        provenance_file_1="path=rogue-fast-prompt.txt;git_sha=6504bf44",
        provenance_file_2="path=demo/rogue/original-rogue;git_sha=6504bf44",
        model_stylesheet="
            * { llm_model: kimi-k2.5; llm_provider: kimi; }
            .hard { llm_model: kimi-k2.5; llm_provider: kimi; }
            .verify { llm_model: kimi-k2.5; llm_provider: kimi; }
            .review { llm_model: kimi-k2.5; llm_provider: kimi; }
        "
    ]

    start [shape=Mdiamond, label="Start"]
    exit  [shape=Msquare, label="Exit"]

    // =========================================================================
    // Toolchain readiness gate
    // =========================================================================

    check_toolchain [
        shape=parallelogram,
        max_retries=0,
        tool_command="bash -lc 'set -euo pipefail; command -v cargo >/dev/null || { echo \"missing required tool: cargo (install via rustup.rs)\" >&2; exit 1; }; command -v rustup >/dev/null || { echo \"missing required tool: rustup (install via rustup.rs)\" >&2; exit 1; }; command -v wasm-pack >/dev/null || { echo \"missing required tool: wasm-pack (install with: cargo install wasm-pack)\" >&2; exit 1; }; rustup target list --installed | grep -qx wasm32-unknown-unknown || { echo \"missing required rust target: wasm32-unknown-unknown (install with: rustup target add wasm32-unknown-unknown)\" >&2; exit 1; }; echo \"toolchain OK: cargo=$(cargo --version), wasm-pack=$(wasm-pack --version), wasm32 target installed\"'"
    ]

    // =========================================================================
    // Phase 1: Spec expansion — bootstrap .ai/spec.md
    // =========================================================================

    expand_spec [
        shape=box,
        auto_status=true,
        max_agent_turns=40,
        prompt="You are bootstrapping a spec for porting Rogue 5.4.4 from C to Rust/WASM.\n\nThe DELIVERABLE is a playable game in a web browser. The user opens demo/rogue/rogue-wasm/www/index.html, and Rogue runs — rendered as classic ASCII in an 80x24 terminal grid, compiled from Rust to WebAssembly via wasm-pack.\n\nRequirements:\n- Exact mechanical port: same dungeon generation algorithms, monster stats, item tables, RNG seed behavior. 1:1 Rust translation of all C game logic.\n- Full scope: dungeon gen, combat, all item types (14 potions, 18 scrolls, 14 rings, 14 sticks, 9 weapons, 8 armors), 26 monster types with chase AI, save/load (localStorage), scoring, wizard mode, options, daemon/fuse scheduling.\n- Build target: Rust -> WASM via wasm-pack + wasm-bindgen (--target web), served from a single HTML page.\n- Rendering: classic ASCII terminal — '@' player, '#' corridors, '.' floors, monster letters A-Z. 80 columns x 24 rows. Monospace font, dark background. Keyboard input for all commands.\n- The C source is at demo/rogue/original-rogue/ (~16,800 lines across 33 .c files).\n\nSource structure (demo/rogue/original-rogue/):\n  Core: main.c (396L), command.c (820L), rogue.h (753L), extern.h (197L), extern.c (391L)\n  Dungeon: rooms.c (472L), passages.c (424L), new_level.c (231L)\n  Combat: fight.c (686L), weapons.c (288L), armor.c (89L)\n  Items: potions.c (375L), scrolls.c (329L), rings.c (204L), sticks.c (431L), things.c (713L)\n  Monsters: monsters.c (252L), chase.c (541L), daemon.c (181L), daemons.c (295L)\n  Player: move.c (425L), pack.c (503L), list.c (113L)\n  UI/IO: io.c (277L), rip.c (449L), options.c (501L)\n  State: state.c (2134L), save.c (390L), init.c (447L)\n  Platform: mach_dep.c (457L), mdport.c (1432L)\n  Misc: misc.c (597L), wizard.c (284L), xcrypt.c (707L), vers.c (17L)\n\nDisambiguation / Assumptions:\n- ncurses is replaced by a WASM-exported API consumed by a JS terminal renderer in index.html.\n- The C THING union becomes a Rust enum. Global state becomes a GameState struct.\n- Save/load uses serde + localStorage (no filesystem).\n- No networking — single-player browser game.\n- The final artifact is: demo/rogue/rogue-wasm/www/index.html that loads pkg/rogue_wasm.js + .wasm.\n\nExpand into a detailed spec covering:\n1. Project layout (Cargo.toml, src/ modules, www/ HTML+JS+CSS)\n2. Rust module map (C files -> Rust modules)\n3. Core type definitions\n4. WASM bridge API (exported functions, JS->Rust event flow)\n5. Terminal renderer spec (80x24 grid, char rendering, color, keyboard handling)\n6. RNG porting strategy (exact C formula reproduction)\n7. System-by-system porting notes\n8. Build pipeline: cargo build --lib, wasm-pack build --target web, then open www/index.html\n9. Test plan: cargo test (unit tests per module), wasm-pack test --headless --chrome\n10. QA acceptance criteria: the game loads in a browser, you can move with hjkl, fight monsters, pick up items, go down stairs, and die with a tombstone\n\nWrite the spec to .ai/spec.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success"
    ]

    // =========================================================================
    // Phase 2: C source analysis
    // =========================================================================

    impl_analysis [
        shape=box,
        class="hard",
        max_agent_turns=60,
        max_retries=8,
        escalation_models="zai:glm-4.7, anthropic:claude-opus-4-6",
        prompt="Goal: $goal\n\nPerform a deep analysis of the entire Rogue C source at demo/rogue/original-rogue/.\n\nRead EVERY .c and .h file. Catalog:\n1. All data structures (structs, unions, typedefs) with field-level detail\n2. All global variables (from extern.c, extern.h, rogue.h) — name, type, initial value, which files read/write them\n3. All #define constants and macros — gameplay constants (MAXROOMS=9, AMULETLEVEL=26, HUNGERTIME=1300, etc.) and convenience macros (when, otherwise, until, ce, hero, pstats, on(), winat, INDEX, chat, flat, moat)\n4. Every function signature grouped by source file, with brief description\n5. Cross-file dependency graph\n6. The ncurses API surface — every ncurses call used and where (mvaddch, move, refresh, getch, WINDOW, waddch, etc.)\n7. Game loop: main() -> playit() -> command() -> do_daemons/do_fuses -> monster turns\n8. Memory patterns (linked list attach/detach, new_item/discard)\n9. RNG: seed = seed*11109+13849, RN macro = (seed >> 16) & 0xffff, rnd(range), roll(n,s), spread(nm)\n10. Platform code in mach_dep.c/mdport.c that needs WASM equivalents vs. can be dropped\n\nWrite the complete analysis to .ai/rogue_analysis.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if analysis is complete, outcome=fail with failure_reason and details otherwise."
    ]

    verify_analysis [
        shape=box,
        class="verify",
        max_agent_turns=24,
        prompt="Verify the C source analysis is comprehensive and accurate.\n\nRead .ai/rogue_analysis.md. Cross-check against actual C source at demo/rogue/original-rogue/:\n\n1. All 33 .c files covered (list each and confirm present in analysis)\n2. All structs from rogue.h documented (THING, PLACE, room, stats, monster, obj_info, h_list, coord, delayed_action)\n3. All globals from extern.c listed (44+ bools, 10+ strings, 15+ ints)\n4. Spot-check 5 functions for accuracy:\n   a. fight() in fight.c — verify parameter list and description\n   b. do_rooms() in rooms.c — verify algorithm description\n   c. chase() in chase.c — verify AI description\n   d. do_pot() in potions.c — verify potion count\n   e. rs_save_file() in state.c — verify serialization scope\n5. ncurses API surface complete (mvaddch, getch, refresh, addch, move, clrtoeol, etc.)\n6. RNG algorithm correctly documented: seed*11109+13849, >>16, &0xffff\n\nWrite results to .ai/verify_analysis.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if comprehensive and accurate, outcome=fail with failure_reason and details listing specific gaps."
    ]

    check_analysis [shape=diamond, label="Analysis OK?"]

    // =========================================================================
    // Phase 3: Architecture design
    // =========================================================================

    impl_architecture [
        shape=box,
        class="hard",
        max_agent_turns=50,
        max_retries=8,
        escalation_models="zai:glm-4.7, anthropic:claude-opus-4-6",
        prompt="Goal: $goal\n\nRead .ai/spec.md and .ai/rogue_analysis.md.\n\nDesign the Rust/WASM architecture. Write .ai/rogue_architecture.md:\n\n1. **Rust Module Layout** (all under demo/rogue/rogue-wasm/src/):\n   lib.rs — #[wasm_bindgen] exports, WASM entry\n   types.rs — Coord, Thing enum, Place, Room, Stats, Monster, ObjInfo, all constants, bitflags\n   rng.rs — exact C RNG port\n   game.rs — GameState struct (all globals), game loop\n   dungeon.rs — rooms, passages, new_level, maze\n   combat.rs — fight, hit/miss, damage, saving throws\n   items.rs — potions, scrolls, rings, sticks, weapons, armor, things, inventory\n   monsters.rs — monster table, chase AI, spawn\n   daemon.rs — daemon/fuse scheduling, specific daemons\n   player.rs — movement, commands, look, search, traps\n   io_bridge.rs — message system, status line (replaces ncurses I/O)\n   state.rs — save/load via serde + localStorage\n   init.rs — initialization, random names/colors/materials\n   score.rs — death screen, tombstone, scoring\n   wizard.rs — wizard mode\n\n2. **Type Mappings**: THING union -> enum Thing { Monster{..}, Object{..} }; globals -> GameState fields; WINDOW -> screen buffer [Cell; 80*24]; C macros -> const/fn; bit flags -> bitflags!\n\n3. **WASM Bridge**: new_game(seed) -> Game; Game.process_key(key) returns JSON {screen: [[{ch,fg,bg}]], message: str, status: str, game_over: bool}; Game.save_to_storage(); Game.load_from_storage()\n\n4. **JS Terminal Renderer** (in www/index.html):\n   - 80x24 <pre> grid or CSS grid of <span> elements\n   - document.onkeydown -> game.process_key(e.key)\n   - Render loop: parse JSON screen, update DOM spans\n   - Color map: curses COLOR_RED/GREEN/etc. -> CSS colors\n\n5. **ncurses Replacement**: mvaddch -> screen_buf[y][x] = Cell; refresh -> noop (JS reads buffer after process_key); getch -> key passed in from JS; all output buffered, returned per-turn\n\n6. **Cross-Module Interfaces**: exact function signatures each module exports, so parallel implementation branches can code against them independently. This is CRITICAL — four parallel branches will implement against these interfaces simultaneously.\n\n7. **Build & Serve**: wasm-pack build --target web produces pkg/; www/index.html loads pkg/rogue_wasm.js; open www/index.html in browser to play\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if architecture is complete, outcome=fail with failure_reason and details otherwise."
    ]

    verify_architecture [
        shape=box,
        class="verify",
        max_agent_turns=24,
        prompt="Verify architecture design is complete and consistent.\n\nRead .ai/rogue_architecture.md and .ai/rogue_analysis.md.\n\n1. Every C file has a Rust module assignment (33 files -> 15 modules)\n2. Every C struct has a Rust type mapping\n3. WASM bridge covers all gameplay interactions (new game, process key, save, load)\n4. ncurses replacement covers all used ncurses functions listed in analysis\n5. Cross-module interfaces defined with function signatures for EVERY module boundary\n6. Build pipeline is clear: wasm-pack build --target web, then open www/index.html\n7. No circular module dependencies\n8. GameState struct accounts for all globals from extern.c\n9. Write-scope partitioning is clear: which modules are safe for parallel implementation\n\nWrite results to .ai/verify_architecture.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if architecture is complete, outcome=fail with failure_reason and details listing specific gaps."
    ]

    check_architecture [shape=diamond, label="Arch OK?"]

    // =========================================================================
    // Phase 4: Scaffold — project setup + core types + RNG + stubs
    // (Interface-pinning: defines ALL shared types for parallel branches)
    // =========================================================================

    impl_scaffold [
        shape=box,
        class="hard",
        max_agent_turns=60,
        max_retries=8,
        escalation_models="zai:glm-4.7, anthropic:claude-opus-4-6",
        prompt="Goal: $goal\n\nRead .ai/spec.md and .ai/rogue_architecture.md.\n\nCreate the Rust/WASM project at demo/rogue/rogue-wasm/. This scaffold defines the SHARED CONTRACT that four parallel implementation branches will code against. Types, constants, and interfaces must be comprehensive.\n\nBuild-first strategy:\n- FIRST MILESTONE: Achieve a clean `cargo build --lib` with stub/skeleton implementations before filling in any logic.\n- If you spend more than a third of your turns on build errors, simplify: comment out broken code, add stubs, get to green, then iterate.\n\n1. **.gitignore**: target/, pkg/, wasm-pack.log, *.wasm\n\n2. **Cargo.toml**:\n   [package] name=\"rogue-wasm\", edition=\"2021\"\n   [lib] crate-type=[\"cdylib\",\"rlib\"]\n   [dependencies] wasm-bindgen=\"0.2\", web-sys={version=\"0.3\",features=[\"Window\",\"Document\",\"Storage\",\"console\"]}, js-sys=\"0.3\", serde={version=\"1\",features=[\"derive\"]}, serde_json=\"1\", bitflags=\"2\"\n   [dev-dependencies] wasm-bindgen-test=\"0.3\"\n\n3. **src/types.rs** — ALL core types from rogue.h (COMPREHENSIVE — branches depend on this):\n   Coord, Stats, Thing enum (Monster/Object variants with all fields), Place, Room, MonsterTemplate, ObjInfo, HelpEntry, DelayedAction, Cell (ch+fg+bg for screen)\n   ALL constants: MAXROOMS=9, MAXTHINGS=9, MAXOBJ=9, MAXPACK=23, MAXTRAPS=10, AMULETLEVEL=26, NUMTHINGS=7, MAXPASS=13, NUMLINES=24, NUMCOLS=80, MAXDAEMONS=20\n   All item type IDs (P_CONFUSE..P_LEVIT, S_CONFUSE..S_PROTECT, weapon/armor/ring/stick types)\n   All flag bits via bitflags! (room: ISDARK/ISGONE/ISMAZE; object: ISCURSED/ISKNOW/etc.; creature: CANHUH/ISRUN/ISMEAN/etc.; map: F_PASS/F_SEEN/etc.)\n   Trap types, display chars (PASSAGE='#', DOOR='+', FLOOR='.', PLAYER='@', etc.)\n\n4. **src/rng.rs** — EXACT C RNG:\n   pub struct Rng { seed: i32 }\n   fn rn(&mut self) -> u16 { self.seed = self.seed.wrapping_mul(11109).wrapping_add(13849); ((self.seed >> 16) & 0xffff) as u16 }\n   fn rnd(&mut self, range: i32) -> i32 { (self.rn() as i32 % range).abs() }\n   fn roll(&mut self, number: i32, sides: i32) -> i32 { sum of number calls to rnd(sides)+1 }\n   fn spread(&mut self, nm: i32) -> i32 { rnd(nm - nm/20 + 1) + nm - nm/10 }\n\n5. **src/game.rs** — GameState struct with ALL globals from extern.c:\n   All bools, strings, ints, level state, rooms array, places grid, player Thing, monster list, object list, daemon list, Rng, screen buffer [Cell; NUMCOLS*NUMLINES]\n\n6. **src/lib.rs** — WASM entry:\n   #[wasm_bindgen] pub struct Game { state: GameState }\n   #[wasm_bindgen] impl Game { pub fn new(seed: u32) -> Game; pub fn process_key(&mut self, key: &str) -> String; pub fn get_screen_json(&self) -> String; pub fn save_game(&self) -> String; pub fn load_game(&mut self, data: &str); }\n   Stub implementations that compile.\n\n7. **Stub modules with CORRECT FUNCTION SIGNATURES** (branches will fill these in):\n   dungeon.rs, combat.rs, items.rs, monsters.rs, daemon.rs, player.rs, io_bridge.rs, state.rs, init.rs, score.rs, wizard.rs\n   Each must have pub fn stubs matching the interfaces in .ai/rogue_architecture.md.\n\n8. **www/index.html** — THE PLAYABLE WEB PAGE:\n   <!DOCTYPE html> with <pre id=\"terminal\"> styled 80x24, black bg, monospace\n   <script type=\"module\"> imports from ../pkg/rogue_wasm.js\n   On load: init WASM, game = Game.new(Date.now()), render initial screen\n   document.onkeydown: result = game.process_key(mapKey(e)); update terminal grid\n   mapKey: ArrowUp->k, ArrowDown->j, ArrowLeft->h, ArrowRight->l, all other keys pass through\n   Render function: parse JSON screen, set each <span> textContent and color\n\nAfter creating everything, run:\n  cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n\nMUST compile with zero errors.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if cargo build --lib succeeds, outcome=fail with failure_reason and details (include compiler errors) otherwise."
    ]

    verify_scaffold [
        shape=box,
        class="verify",
        max_agent_turns=24,
        prompt="Verify project scaffold compiles and is structurally complete for parallel branching.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail if formatting issues\n3. Structural checks:\n   - src/types.rs defines Coord, Thing, Place, Room, Stats, all constants, all bitflags\n   - src/rng.rs has the exact formula: seed*11109+13849, shift right 16, mask 0xffff\n   - src/game.rs defines GameState with screen buffer, rooms, places, player, monsters\n   - src/lib.rs has #[wasm_bindgen] Game with new(), process_key(), get_screen_json()\n   - All 11 stub modules exist with pub fn stubs (dungeon, combat, items, monsters, daemon, player, io_bridge, state, init, score, wizard)\n   - www/index.html exists with terminal <pre>, WASM import, keyboard handler\n   - Cargo.toml has wasm-bindgen, web-sys, serde, bitflags\n   - .gitignore excludes target/ and pkg/\n4. Interface completeness: each stub module has the function signatures defined in .ai/rogue_architecture.md\n5. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns (*.bak, *.tmp, *.orig).\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_scaffold.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all pass, outcome=fail with failure_reason and details."
    ]

    check_scaffold [shape=diamond, label="Scaffold OK?"]

    // =========================================================================
    // Phase 5: Parallel system port — 2x GLM + 2x Kimi fan-out
    // =========================================================================

    fanout [shape=component, label="Fan Out: Port All Systems"]

    // --- Branch A: Dungeon Generation (GLM 4.7) ---
    // Write scope: src/dungeon.rs ONLY
    // Read-only: src/types.rs, src/game.rs, src/rng.rs, src/lib.rs, Cargo.toml

    impl_dungeon [
        shape=box,
        class="hard",
        max_agent_turns=60,
        max_retries=8,
        escalation_models="zai:glm-4.7, anthropic:claude-opus-4-6",
        prompt="Goal: $goal\n\nPort the dungeon generation system from C to Rust. The final game runs as WASM in a browser.\n\nRead C source:\n- demo/rogue/original-rogue/rooms.c (472 lines)\n- demo/rogue/original-rogue/passages.c (424 lines)\n- demo/rogue/original-rogue/new_level.c (231 lines)\n- demo/rogue/original-rogue/rogue.h\n\nRead Rust project:\n- demo/rogue/rogue-wasm/src/types.rs, src/game.rs, src/rng.rs\n- .ai/rogue_architecture.md (module interfaces)\n\nWRITE SCOPE: You may ONLY modify demo/rogue/rogue-wasm/src/dungeon.rs. Do NOT modify src/types.rs, src/game.rs, src/rng.rs, src/lib.rs, Cargo.toml, or any other module — these are shared contracts used by parallel branches.\n\nImplement demo/rogue/rogue-wasm/src/dungeon.rs — EXACT ports of:\n\n1. do_rooms() — 3x3 grid room generation (rooms laid out in 3 rows x 3 cols), dark/gone/maze rooms, random sizes within grid cells\n2. draw_room() — wall drawing using horiz()/vert(), floor fill with FLOOR char\n3. horiz() / vert() — border line drawing\n4. door() — place doors on room edges (1-2 per side, on wall positions)\n5. do_passages() — corridor connection algorithm linking room exits\n6. conn() — connect two rooms via recursive corridor path-finding\n7. add_pass() / passnum() / numpass() — passage numbering/identification\n8. new_level() — full level gen orchestrator: clear map, do_rooms(), do_passages(), place stairs, generate objects, distribute traps/gold\n9. do_maze() / accnt_maze() — maze generation for ISMAZE rooms\n10. treas_room() — treasure room with extra items and monsters\n11. rnd_room() — random non-gone room selector\n12. find_floor() — find empty floor position in room or level\n\nAll algorithms must be EXACT mechanical ports — same constants, same randomization sequence, same grid layout. Use GameState.rng for all random calls. Write to GameState.places and GameState.rooms.\n\nAlso write at least 3 #[cfg(test)] unit tests:\n- test_rng_determinism: same seed produces same rnd() sequence\n- test_room_generation: do_rooms with fixed seed produces valid rooms (all within bounds, non-zero sizes for non-gone rooms)\n- test_new_level: new_level produces a map with stairs, at least one non-gone room, valid places grid\n\nRun: cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 && cargo test 2>&1\n\nWrite implementation log to .ai/port_dungeon.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if compiles and tests pass, outcome=fail with failure_reason and details (include compiler/test errors) otherwise."
    ]

    verify_dungeon [
        shape=box,
        class="verify",
        max_agent_turns=24,
        prompt="Verify dungeon generation port is correct and faithful to C source.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. cd demo/rogue/rogue-wasm && cargo test dungeon 2>&1 — all dungeon tests must pass\n4. Write-scope check: git diff --name-only $base_sha -- 'demo/rogue/rogue-wasm/src/*.rs' should show ONLY dungeon.rs modified. If any other .rs file was changed, fail with failure_reason=write_scope_violation.\n5. Fidelity spot-checks (compare src/dungeon.rs against C source):\n   a. do_rooms() matches rooms.c 3x3 grid layout with MAXROOMS=9\n   b. conn() matches passages.c corridor algorithm\n   c. new_level() initialization sequence matches new_level.c (clear, rooms, passages, stairs, objects, traps)\n   d. Maze generation matches rooms.c do_maze()\n   e. Constants: room grid cell sizes, min/max room dimensions\n6. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_dungeon.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all checks pass and port is faithful, outcome=fail with failure_reason and details."
    ]

    check_dungeon [shape=diamond, label="Dungeon OK?"]

    // --- Branch B: Combat + Items (Kimi K2.5) ---
    // Write scope: src/combat.rs, src/items.rs ONLY
    // Read-only: src/types.rs, src/game.rs, src/rng.rs, src/lib.rs, Cargo.toml

    impl_combat_items [
        shape=box,
        class="hard",
        max_agent_turns=60,
        max_retries=8,
        escalation_models="zai:glm-4.7, anthropic:claude-opus-4-6",
        prompt="Goal: $goal\n\nPort the combat and item systems from C to Rust. The final game runs as WASM in a browser.\n\nRead C source:\n- demo/rogue/original-rogue/fight.c (686 lines), weapons.c (288 lines), armor.c (89 lines)\n- demo/rogue/original-rogue/potions.c (375 lines), scrolls.c (329 lines), rings.c (204 lines), sticks.c (431 lines), things.c (713 lines)\n- demo/rogue/original-rogue/rogue.h\n\nRead Rust project:\n- demo/rogue/rogue-wasm/src/types.rs, src/game.rs, src/rng.rs\n- .ai/rogue_architecture.md\n\nWRITE SCOPE: You may ONLY modify demo/rogue/rogue-wasm/src/combat.rs and demo/rogue/rogue-wasm/src/items.rs. Do NOT modify src/types.rs, src/game.rs, src/rng.rs, src/lib.rs, Cargo.toml, or any other module — these are shared contracts used by parallel branches.\n\nImplement TWO files:\n\n**src/combat.rs** — exact ports of:\n- fight() — melee resolution\n- attack() — player attacks monster\n- hit_monster() — resolve hit at position\n- swing() — to-hit roll (at_lvl, op_arm, wplus)\n- roll_em() — dice parser and roller (\"2d6+3\" format from s_dmg)\n- hit() / miss() — combat messages\n- bounce() / fire_bolt() — bolt projectile physics\n- killed() — monster death, XP, drops\n- thunk() — thrown weapon messages\n- save_throw() — saving throw\n- check_level() / raise_level() — level-up\n- is_magic() — item magic check\n\n**src/items.rs** — exact ports of:\n- Static data: pot_info[14], scr_info[18], ring_info[14], ws_info[14], weap_info[9], arm_info[8], things[7] — exact probability weights and names from things.c\n- new_thing() / pick_one() — weighted random item generation\n- inv_name() / nameit() / choose_str() / vowelstr() — name formatting\n- do_pot() — all 14 potion effects\n- quaff() — drink potion\n- read_scroll() — all 18 scroll effects\n- ring_on() / ring_off() / ring_eat() — ring management\n- do_zap() / fix_stick() — wand/staff effects\n- missile() / do_motion() — thrown weapons\n- drop() / dropcheck() — dropping items\n- eat() — food consumption\n- wear() / take_off() — armor\n- wield() — weapons\n- current() — equipment description\n- whatis() / identify() / call() / call_it() — identification\n- init_weapon() / fall() — weapon init, item drop\n- add_pack() / pack_room() / leave_pack() / inventory() / pick_up() — pack management\n- money() / set_know() / set_order() / pick_color() / charge_str() / ring_num() / num()\n\nUnit tests (at least 3):\n- test_roll_em: verify dice parsing \"2d6\" produces values in [2,12]\n- test_swing: verify to-hit calculation matches C formula\n- test_pick_one: verify weighted selection from things[] produces valid types\n\nRun: cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 && cargo test 2>&1\n\nWrite log to .ai/port_combat_items.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if compiles and tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_combat_items [
        shape=box,
        class="verify",
        max_agent_turns=24,
        prompt="Verify combat/items port is correct and faithful to C source.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. cd demo/rogue/rogue-wasm && cargo test combat items 2>&1 — tests must pass\n4. Write-scope check: git diff --name-only $base_sha -- 'demo/rogue/rogue-wasm/src/*.rs' should show ONLY combat.rs and items.rs modified. If any other .rs file was changed, fail with failure_reason=write_scope_violation.\n5. Fidelity spot-checks against C source:\n   a. fight()/swing()/roll_em() match fight.c\n   b. All 14 potion effects match potions.c\n   c. All 18 scroll effects match scrolls.c\n   d. pot_info/scr_info/ring_info/ws_info tables match things.c exactly\n   e. Weapon damage strings match weapons.c\n   f. Armor AC values match armor.c\n6. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_combat_items.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all checks pass and port is faithful, outcome=fail with failure_reason and details."
    ]

    check_combat_items [shape=diamond, label="Combat+Items OK?"]

    // --- Branch C: Monsters + AI + Daemons (GLM 4.7) ---
    // Write scope: src/monsters.rs, src/daemon.rs ONLY
    // Read-only: src/types.rs, src/game.rs, src/rng.rs, src/lib.rs, Cargo.toml

    impl_monsters [
        shape=box,
        class="hard",
        max_agent_turns=60,
        max_retries=8,
        escalation_models="zai:glm-4.7, anthropic:claude-opus-4-6",
        prompt="Goal: $goal\n\nPort the monster, AI, and daemon systems from C to Rust. The final game runs as WASM in a browser.\n\nRead C source:\n- demo/rogue/original-rogue/monsters.c (252 lines), chase.c (541 lines)\n- demo/rogue/original-rogue/daemon.c (181 lines), daemons.c (295 lines)\n- demo/rogue/original-rogue/misc.c (aggravate, set_oldch, find_dest, rndmove, relocate)\n- demo/rogue/original-rogue/rogue.h\n\nRead Rust project:\n- demo/rogue/rogue-wasm/src/types.rs, src/game.rs, src/rng.rs\n- .ai/rogue_architecture.md\n\nWRITE SCOPE: You may ONLY modify demo/rogue/rogue-wasm/src/monsters.rs and demo/rogue/rogue-wasm/src/daemon.rs. Do NOT modify src/types.rs, src/game.rs, src/rng.rs, src/lib.rs, Cargo.toml, or any other module — these are shared contracts used by parallel branches.\n\nImplement TWO files:\n\n**src/monsters.rs** — exact ports of:\n- MONSTERS static: all 26 types (A-Z) with exact stats from monsters[]: name, carry%, flags, STR, EXP, LVL, AC, HP, damage. E.g. 'A' = \"aquator\", carry=0, ISMEAN, STR=10, EXP=20, LVL=5, AC=2, HP=1d8, dmg=\"0d0/0d0\"\n- new_monster() — spawn, set stats from template\n- randmonster() — level-appropriate random selection\n- wanderer() — wandering monster spawn\n- wake_monster() — wake on room entry\n- give_pack() — random monster inventory\n- see_monst() / set_mname() — visibility, naming\n- remove_mon() — remove from level\n- find_dest() / rndmove() / relocate() — from misc.c\n- aggravate() / set_oldch() — from misc.c\n- Chase AI: chase(), do_chase(), runto(), move_monst(), diag_ok(), cansee(), dist(), dist_cp(), turn_ok()\n\n**src/daemon.rs** — exact ports of:\n- d_list: [DelayedAction; MAXDAEMONS] in GameState\n- start_daemon() / kill_daemon() / do_daemons(flag)\n- fuse() / lengthen() / extinguish() / do_fuses(flag)\n- Specific daemons: runners(), doctor(), stomach(), swander(), come_down(), unconfuse(), unsee(), sight(), visuals(), nohaste(), land(), rollwand()\n- Timing: HEALTIME=30, HUNGERTIME=1300, MORETIME=150, STOMACHSIZE=2000, STARVETIME=850, WANDERTIME=spread(70), etc.\n\nUnit tests (at least 3):\n- test_monster_table: all 26 entries present with correct types\n- test_daemon_lifecycle: start_daemon, do_daemons fires it, kill_daemon removes it\n- test_hunger_system: stomach() decrements food_left, transitions through hunger states\n\nRun: cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 && cargo test 2>&1\n\nWrite log to .ai/port_monsters.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if compiles and tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_monsters [
        shape=box,
        class="verify",
        max_agent_turns=24,
        prompt="Verify monster/AI/daemon port is correct and faithful to C source.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. cd demo/rogue/rogue-wasm && cargo test monster daemon 2>&1 — tests must pass\n4. Write-scope check: git diff --name-only $base_sha -- 'demo/rogue/rogue-wasm/src/*.rs' should show ONLY monsters.rs and daemon.rs modified. If any other .rs file was changed, fail with failure_reason=write_scope_violation.\n5. Fidelity spot-checks against C source:\n   a. All 26 monster entries match monsters.c (spot-check A, D, E, M, V, Z)\n   b. chase/do_chase matches chase.c\n   c. daemon scheduling matches daemon.c\n   d. Hunger timing matches daemons.c (HUNGERTIME=1300, MORETIME=150)\n   e. HP regen formula matches doctor() in daemons.c: 1 HP per (21-level), min 3\n6. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_monsters.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all checks pass and port is faithful, outcome=fail with failure_reason and details."
    ]

    check_monsters [shape=diamond, label="Monsters OK?"]

    // --- Branch D: Player + IO + State + Init + Score + Wizard (Kimi K2.5) ---
    // Write scope: src/player.rs, src/io_bridge.rs, src/state.rs, src/init.rs, src/score.rs, src/wizard.rs ONLY
    // Read-only: src/types.rs, src/game.rs, src/rng.rs, src/lib.rs, Cargo.toml

    impl_player_io [
        shape=box,
        class="hard",
        max_agent_turns=60,
        max_retries=8,
        escalation_models="zai:glm-4.7, anthropic:claude-opus-4-6",
        prompt="Goal: $goal\n\nPort player, I/O, and state systems from C to Rust. All I/O goes through the WASM bridge, not ncurses.\n\nRead C source:\n- demo/rogue/original-rogue/move.c (425L), command.c (820L), pack.c (503L)\n- demo/rogue/original-rogue/io.c (277L), list.c (113L)\n- demo/rogue/original-rogue/save.c (390L), state.c (2134L)\n- demo/rogue/original-rogue/init.c (447L), options.c (501L)\n- demo/rogue/original-rogue/rip.c (449L), wizard.c (284L), misc.c\n- demo/rogue/original-rogue/rogue.h\n\nRead Rust project:\n- demo/rogue/rogue-wasm/src/types.rs, src/game.rs, src/rng.rs\n- .ai/rogue_architecture.md\n\nWRITE SCOPE: You may ONLY modify these files in demo/rogue/rogue-wasm/src/: player.rs, io_bridge.rs, state.rs, init.rs, score.rs, wizard.rs. Do NOT modify src/types.rs, src/game.rs, src/rng.rs, src/lib.rs, Cargo.toml, or any other module — these are shared contracts used by parallel branches.\n\nImplement SIX files:\n\n**src/player.rs** — from command.c, move.c, misc.c:\n- command() — full dispatch: h/j/k/l/y/u/b/n movement, H/J/K/L/Y/U/B/N running, . wait, > down, < up, e eat, q quaff, r read, w wield, W wear, T take off, P put ring, R remove ring, d drop, c call, D discovered, i inventory, s search, z zap, t throw, f fight-to-death, ? help, / identify, ^R redraw, Q quit, S save, ! shell (noop in WASM)\n- do_move() / do_run() — movement, running\n- look() — visibility update\n- enter_room() / leave_room() / erase_lamp() — room transitions\n- search() / be_trapped() — traps\n- door_open() / teleport() / d_level() / u_level()\n- help() / show_map() / show_win() / status() / waste_time() / illcom()\n\n**src/io_bridge.rs** — from io.c (NO ncurses — buffer to screen grid):\n- msg() / addmsg() / endmsg() — message line (row 0 of screen buffer)\n- status() — status line (row NUMLINES-1): \"Level: X Hits: X(X) Str: X Gold: X Armor: X Exp: X/X\"\n- readchar() — returns next key from JS queue (stored in GameState)\n- wait_for() — wait for specific key\n- All output writes to GameState.screen buffer, consumed by JS renderer\n\n**src/state.rs** — from save.c, state.c (WASM-adapted):\n- save_game() -> String — serialize GameState via serde_json\n- load_game(data: &str) -> GameState — deserialize\n- Must cover: rooms, places, player, monsters, items, daemons, RNG seed, all flags\n\n**src/init.rs** — from init.c, options.c:\n- init_player() — STR 16, HP 12, LVL 1, AC 10, EXP 0, starting weapon (mace), armor (ring mail), food\n- init_colors() / init_stones() / init_materials() / init_names() / init_probs()\n- parse_opts() / option() — game options (name, fruit, terse, jump, etc.)\n\n**src/score.rs** — from rip.c:\n- death(monst) — death handler, show tombstone\n- total_winner() — amulet victory\n- score() — scoring display\n- Tombstone ASCII art (exact from rip.c)\n\n**src/wizard.rs** — from wizard.c:\n- create_obj(), show_map(), teleport(), wizard commands\n- passwd() — wizard password\n\nUnit tests (at least 3):\n- test_command_dispatch: verify all key bindings produce correct action\n- test_init_player: starting stats match (STR=16, HP=12, LVL=1)\n- test_save_load_roundtrip: save then load produces identical GameState\n\nRun: cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 && cargo test 2>&1\n\nWrite log to .ai/port_player_io.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if compiles and tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_player_io [
        shape=box,
        class="verify",
        max_agent_turns=24,
        prompt="Verify player/IO/state port is correct and faithful to C source.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. cd demo/rogue/rogue-wasm && cargo test player io init score wizard state 2>&1 — tests must pass\n4. Write-scope check: git diff --name-only $base_sha -- 'demo/rogue/rogue-wasm/src/*.rs' should show ONLY player.rs, io_bridge.rs, state.rs, init.rs, score.rs, wizard.rs modified. If any other .rs file was changed, fail with failure_reason=write_scope_violation.\n5. Fidelity spot-checks against C source:\n   a. command() dispatches all keys from command.c\n   b. do_move() matches move.c\n   c. Message system matches io.c\n   d. Status line format: \"Level: X  Hits: X(X)  Str: X  Gold: X  Armor: X  Exp: X/X\"\n   e. Tombstone ASCII art matches rip.c\n   f. init_player() stats match init.c (STR=16, HP=12)\n   g. save/load roundtrip works\n6. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_player_io.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all checks pass and port is faithful, outcome=fail with failure_reason and details."
    ]

    check_player_io [shape=diamond, label="Player+IO OK?"]

    // Fan-in
    fanin [shape=tripleoctagon, label="Fan In: Merge Ports"]

    // =========================================================================
    // Phase 6: Integration — wire into playable WASM game
    // =========================================================================

    impl_integration [
        shape=box,
        class="hard",
        max_agent_turns=60,
        max_retries=8,
        escalation_models="zai:glm-4.7, anthropic:claude-opus-4-6",
        prompt="Goal: $goal\n\nAll four system ports are complete. Integrate into a playable browser game.\n\nRead: .ai/rogue_architecture.md, .ai/port_dungeon.md, .ai/port_combat_items.md, .ai/port_monsters.md, .ai/port_player_io.md\nRead: all files in demo/rogue/rogue-wasm/src/\n\nBuild-first strategy:\n- FIRST MILESTONE: Achieve a clean `cargo build --lib` with all modules wired together before filling in complex logic.\n- If you spend more than a third of your turns on build errors, simplify: add stubs, get to green, then iterate.\n\nIntegration tasks:\n\n1. **Main game loop** in src/game.rs — wire the exact C turn sequence:\n   new_game(seed): init RNG -> init_player -> init_colors/stones/materials/names/probs -> new_level() -> start_daemon(runners/doctor/stomach/swander)\n   process_key(key): look() -> status() -> command dispatch -> do_daemons(BEFORE) -> do_fuses(BEFORE) -> move_monst() -> do_daemons(AFTER) -> do_fuses(AFTER) -> update screen -> return frame\n\n2. **Cross-module wiring**:\n   - new_level() calls new_monster(), put_things(), add gold\n   - command() calls combat, items, dungeon, player functions\n   - killed() calls give_pack(), add XP, check_level()\n   - Daemon callbacks reference runners/doctor/stomach/swander\n   - Resolve ALL borrow checker issues\n\n3. **WASM bridge** in src/lib.rs:\n   #[wasm_bindgen] Game wrapping GameState\n   new(seed: u32) -> Game — calls new_game\n   process_key(&mut self, key: &str) -> String — JSON: {screen: [[{ch,fg,bg}; 80]; 24], message: String, status: String, game_over: bool}\n   save_game(&self) -> String\n   load_game(&mut self, data: &str)\n\n4. **HTML frontend** — update www/index.html to be FULLY PLAYABLE:\n   <pre id=\"terminal\"> styled: width:80ch, height:24 lines, font-family:monospace, background:#000, color:#0f0\n   WASM import: import init, { Game } from '../pkg/rogue_wasm.js'\n   On load: await init(), game = Game.new(Date.now()), render()\n   Keyboard: document.addEventListener('keydown', e => { result = game.process_key(mapKey(e)); render(JSON.parse(result)); e.preventDefault(); })\n   mapKey: ArrowUp->k, ArrowDown->j, ArrowLeft->h, ArrowRight->l, all other keys pass through\n   Render: for each row/col, set span text and color from screen data\n   Game over: show message, offer restart\n   Save/Load: buttons or S key triggers localStorage save\n\n5. **Build and verify**:\n   cd demo/rogue/rogue-wasm && wasm-pack build --target web 2>&1\n   Verify pkg/ contains rogue_wasm.js and rogue_wasm_bg.wasm\n   Verify www/index.html correctly imports from ../pkg/\n\nThe game MUST compile to WASM. After wasm-pack build, a user should be able to open www/index.html (via a local server) and play Rogue.\n\nWrite log to .ai/integration_log.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if wasm-pack build succeeds, outcome=fail with failure_reason and details otherwise."
    ]

    verify_integration [
        shape=box,
        class="verify",
        max_agent_turns=30,
        prompt="Verify full WASM integration is correct and complete.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. cd demo/rogue/rogue-wasm && wasm-pack build --target web 2>&1 — must succeed\n4. ls demo/rogue/rogue-wasm/pkg/ — must contain rogue_wasm.js and rogue_wasm_bg.wasm\n5. Verify www/index.html imports from ../pkg/rogue_wasm.js\n6. Verify www/index.html has: terminal grid, keyboard handler, render function, WASM init\n7. Verify Game struct exports: new(), process_key(), save_game(), load_game()\n8. Verify game loop in game.rs follows C turn order\n9. cd demo/rogue/rogue-wasm && cargo test 2>&1 — all unit tests pass\n10. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, dist/, build/, or backup/temp patterns. Note: pkg/ is expected output from wasm-pack build.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_integration.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all pass, outcome=fail with failure_reason and details."
    ]

    check_integration [shape=diamond, label="WASM OK?"]

    // =========================================================================
    // Phase 7: QA — dedicated test suite
    // =========================================================================

    impl_qa [
        shape=box,
        class="hard",
        max_agent_turns=50,
        max_retries=8,
        escalation_models="zai:glm-4.7, anthropic:claude-opus-4-6",
        prompt="Goal: $goal\n\nThe game compiles to WASM. Now add comprehensive tests and verify correctness.\n\nRead: .ai/rogue_analysis.md (C behavior reference), all demo/rogue/rogue-wasm/src/ files.\n\nAdd tests in demo/rogue/rogue-wasm/src/ modules:\n\n1. **RNG fidelity test** (critical):\n   - Port the C RNG test: seed=42, call rnd(100) 20 times, record values\n   - Compute expected values from C formula (seed=seed*11109+13849; rn=(seed>>16)&0xffff; rnd=rn%range)\n   - The sequences MUST match exactly\n\n2. **Dungeon generation tests**:\n   - Fixed seed produces identical room layouts\n   - All rooms within bounds (0..NUMCOLS, 0..NUMLINES)\n   - Passages connect rooms (BFS from room 0 reaches all non-gone rooms)\n   - Stairs exist on every level\n\n3. **Monster table integrity**:\n   - 26 monsters A-Z all defined\n   - Stats match C source values exactly\n   - Spot-check: 'D' dragon carry=100, flags=ISMEAN, dmg=\"1d8/1d8/3d10\"\n\n4. **Combat math tests**:\n   - swing() with known inputs matches C formula\n   - roll_em() dice parsing: \"2d6\" -> [2,12], \"1d4\" -> [1,4]\n   - save_throw() with known level/type matches C\n\n5. **Item generation tests**:\n   - pick_one() probability distribution matches cum_prob tables\n   - All 14 potions, 18 scrolls, 14 rings, 14 sticks generatable\n\n6. **Game loop integration test**:\n   - Create game with fixed seed\n   - Send key sequence: wait, move right, move down, wait\n   - Verify screen changes (player '@' moves)\n   - Verify status line updates\n\n7. **Save/load roundtrip test**:\n   - Create game, make some moves\n   - save_game() -> JSON string\n   - load_game(json) -> new state\n   - Compare: same level, same player position, same HP, same inventory\n\n8. **WASM binding test** (wasm-bindgen-test):\n   - Game::new(42) succeeds\n   - process_key(\"l\") returns valid JSON\n   - get_screen_json() returns parseable 80x24 grid\n\nRun:\n  cd demo/rogue/rogue-wasm && cargo test 2>&1\n  cd demo/rogue/rogue-wasm && wasm-pack test --node 2>&1 || echo \"wasm-pack test skipped (no headless browser)\"\n\nWrite test results to .ai/qa_results.md with pass/fail per category.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all tests pass, outcome=fail with failure_reason and details listing each failure."
    ]

    verify_qa [
        shape=box,
        class="verify",
        max_agent_turns=24,
        prompt="Verify QA test suite is comprehensive and passing.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. cd demo/rogue/rogue-wasm && cargo test 2>&1 — capture full output, count total/passed/failed\n4. cd demo/rogue/rogue-wasm && wasm-pack test --node 2>&1 || echo \"wasm-pack test unavailable\"\n5. Check .ai/qa_results.md includes all 8 categories with pass/fail\n6. If any test fails, document exactly which and why\n7. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_qa.md (include totals: passed/failed/skipped).\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if ALL tests pass (0 failures), outcome=fail with failure_reason and details."
    ]

    check_qa [shape=diamond, label="QA Pass?"]

    // =========================================================================
    // Phase 8: Final review
    // =========================================================================

    review [
        shape=box,
        class="review",
        goal_gate=true,
        max_agent_turns=50,
        prompt="Goal: $goal\n\nFinal review of the complete Rogue C-to-Rust/WASM port. You are reviewing work done by other models.\n\nRead: .ai/spec.md, .ai/rogue_analysis.md, .ai/rogue_architecture.md, .ai/qa_results.md\nRead: all files in demo/rogue/rogue-wasm/src/, demo/rogue/rogue-wasm/www/index.html\n\nReview checklist:\n\n1. **WASM deliverable**: Run `cd demo/rogue/rogue-wasm && wasm-pack build --target web 2>&1`. MUST succeed. Verify pkg/ has .wasm + .js. Verify www/index.html loads the WASM and renders a terminal.\n\n2. **Completeness**: Cross-reference .ai/rogue_analysis.md — is every C function ported?\n   - Count functions in analysis vs. implemented Rust functions\n   - Flag any missing systems\n\n3. **Fidelity spot-checks** (compare Rust code against C source directly):\n   a. RNG: seed*11109+13849 >> 16 & 0xffff\n   b. Room gen: 3x3 grid, MAXROOMS=9, size randomization\n   c. Monster table: all 26 entries, check 'E'=emu, 'M'=medusa, 'V'=vampire stats\n   d. Combat: swing() = at_lvl - op_arm + wplus, roll_em() dice parsing\n   e. Hunger: HUNGERTIME=1300, state transitions at 300/150/0\n   f. HP regen: 1HP per (21-level) turns, min 3\n   g. Scroll S_TELEP: teleports player to random position\n   h. Potion P_HASTE: doubles speed, stacks cause confusion\n   i. Trap T_ARROW: 1d6 damage\n   j. XP table: e_levels = [10,20,40,80,160,320,640,1300,2600,5200,...]\n\n4. **Browser playability**: Does www/index.html:\n   - Import WASM correctly?\n   - Have keyboard handler for all game commands?\n   - Render 80x24 ASCII grid?\n   - Handle game over state?\n\n5. **QA**: All tests pass (check .ai/qa_results.md and .ai/verify_qa.md)\n\n6. **Missing features**: wizard mode, save/load, scoring, options — all present?\n\nSandboxed validation policy:\n- Required checks scoped to demo/rogue/rogue-wasm only.\n- Repo-wide network-dependent checks are advisory only.\n\n7. **Build verification**:\n   cd demo/rogue/rogue-wasm && cargo test 2>&1\n   cd demo/rogue/rogue-wasm && wasm-pack build --target web 2>&1\n\nWrite detailed review to .ai/final_review.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if port is complete, faithful, and playable, outcome=fail with failure_reason and details listing specific issues."
    ]

    check_review [shape=diamond, label="Review OK?"]

    // =========================================================================
    // Edges
    // =========================================================================

    // Toolchain gate
    start -> check_toolchain
    check_toolchain -> expand_spec          [condition="outcome=success"]

    // Spec + Analysis
    expand_spec -> impl_analysis
    impl_analysis -> verify_analysis -> check_analysis
    check_analysis -> impl_architecture     [condition="outcome=success"]
    check_analysis -> impl_analysis         [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_analysis -> impl_analysis         [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Architecture
    impl_architecture -> verify_architecture -> check_architecture
    check_architecture -> impl_scaffold     [condition="outcome=success"]
    check_architecture -> impl_architecture [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_architecture -> impl_architecture [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Scaffold (interface-pinning: must complete before fan-out)
    impl_scaffold -> verify_scaffold -> check_scaffold
    check_scaffold -> fanout                [condition="outcome=success"]
    check_scaffold -> impl_scaffold         [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_scaffold -> impl_scaffold         [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Fan-out -> 4 parallel branches (2x GLM + 2x Kimi)
    fanout -> impl_dungeon
    fanout -> impl_combat_items
    fanout -> impl_monsters
    fanout -> impl_player_io

    // Branch A: Dungeon (GLM 4.7)
    impl_dungeon -> verify_dungeon -> check_dungeon
    check_dungeon -> fanin                  [condition="outcome=success"]
    check_dungeon -> impl_dungeon           [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_dungeon -> impl_dungeon           [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Branch B: Combat/Items (Kimi K2.5)
    impl_combat_items -> verify_combat_items -> check_combat_items
    check_combat_items -> fanin             [condition="outcome=success"]
    check_combat_items -> impl_combat_items [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_combat_items -> impl_combat_items [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Branch C: Monsters/Daemons (GLM 4.7)
    impl_monsters -> verify_monsters -> check_monsters
    check_monsters -> fanin                 [condition="outcome=success"]
    check_monsters -> impl_monsters         [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_monsters -> impl_monsters         [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Branch D: Player/IO/State (Kimi K2.5)
    impl_player_io -> verify_player_io -> check_player_io
    check_player_io -> fanin                [condition="outcome=success"]
    check_player_io -> impl_player_io       [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_player_io -> impl_player_io       [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Post fan-in: Integration
    fanin -> impl_integration
    impl_integration -> verify_integration -> check_integration
    check_integration -> impl_qa            [condition="outcome=success"]
    check_integration -> impl_integration   [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_integration -> impl_integration   [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // QA
    impl_qa -> verify_qa -> check_qa
    check_qa -> review                      [condition="outcome=success"]
    check_qa -> impl_qa                     [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_qa -> impl_qa                     [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Final review — failure loops to late integration node, NOT beginning
    review -> check_review
    check_review -> exit                    [condition="outcome=success"]
    check_review -> impl_integration        [condition="outcome=fail && context.failure_class=transient_infra", label="fix-infra", loop_restart=true]
    check_review -> impl_integration        [condition="outcome=fail && context.failure_class!=transient_infra", label="fix"]
}
